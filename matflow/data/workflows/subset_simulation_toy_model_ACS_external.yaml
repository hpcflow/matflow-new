template_components:
  task_schemas:
    - objective: sample_direct_MC
      inputs:
        - parameter: dimension
      outputs:
        - parameter: x
      actions:
        - script: <<script:uq/sample_direct_MC.py>>
          script_data_in: direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: collate_results
      inputs:
        - parameter: g
          group: all
        - parameter: x
          group: all
        - parameter: all_g
          group: all
          default_value: null
        - parameter: all_x
          group: all
          default_value: null
        - parameter: all_accept
          group: all
          default_value: null
        - parameter: p_0
      outputs:
        - parameter: chain_seeds
        - parameter: chain_g
        - parameter: threshold
        - parameter: num_chains
        - parameter: num_failed
        - parameter: level_pf
        - parameter: level_cov
        - parameter: pf
        - parameter: is_finished
        - parameter: accept_rate
      actions:
        - script: <<script:uq/collate_results.py>>
          script_data_in:
            g: { format: direct, all_iterations: true }
            "*": direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: initialise_markov_chains
      inputs:
        - parameter: chain_index
        - parameter: chain_seeds
        - parameter: chain_g
        - parameter: all_x
        - parameter: all_g
        - parameter: num_chains_per_update
        - parameter: all_accept
      outputs:
        - parameter: x
        - parameter: g
        - parameter: all_x
        - parameter: all_g
        - parameter: all_accept
      actions:
        - script: <<script:uq/initialise_markov_chains_ACS.py>>
          script_data_in:
            chain_index: { format: direct, all_iterations: true }
            "*": direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: generate_next_state
      inputs:
        - parameter: x
        - parameter: prop_std
        - parameter: lambda_
      outputs:
        - parameter: x
      actions:
        - script: <<script:uq/generate_next_state_ACS.py>>
          script_data_in: direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: increment_chain
      inputs:
        - parameter: x
        - parameter: g
        - parameter: all_x
        - parameter: all_g
        - parameter: all_accept
        - parameter: threshold
      outputs:
        - parameter: x
        - parameter: g
        - parameter: all_x
        - parameter: all_g
        - parameter: all_accept
      actions:
        - script: <<script:uq/increment_chain.py>>
          script_data_in: direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: update_proposal
      inputs:
        - parameter: lambda_
          default_value: 1.0
        - parameter: all_accept
          group: all
          default_value: null
        - parameter: all_x
          group: all
          default_value: null
        - parameter: all_g
          group: all
          default_value: null
      outputs:
        - parameter: lambda_
        - parameter: all_x
        - parameter: all_g
        - parameter: all_accept
      actions:
        - script: <<script:uq/update_proposal.py>>
          script_data_in:
            lambda_: { format: direct, all_iterations: true }
            "*": direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: dummy_pre_processor
      inputs:
        - parameter: x
      outputs:
        - parameter: "y"
      actions:
        - script: <<script:uq/dummy_pre_processor.py>>
          script_data_in: direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

    - objective: model_sum_x
      inputs:
        - parameter: "y"
      outputs:
        - parameter: sum_y
      actions:
        - rules:
            - path: resources.os_name
              condition: { value.equal_to: nt }
          commands:
            - command: 'Write-Output $(<<join[delim=" + "](parameter:y)>>)'
              stdout: "<<float(parameter:sum_y)>>"
        - rules:
            - path: resources.os_name
              condition: { value.equal_to: posix }
          commands:
            - command: echo 'print(<<join[delim=" + "](parameter:y)>>)' | python
              stdout: "<<float(parameter:sum_y)>>"

    - objective: evaluate_limit_state_normal_sum
      inputs:
        - parameter: x # required to ensure group defined on input x (not needed by this task)
        - parameter: sum_y
        - parameter: target_pf
        - parameter: dimension
      outputs:
        - parameter: g
      actions:
        - script: <<script:uq/evaluate_limit_state_normal_sum.py>>
          script_data_in: direct
          script_data_out: direct
          script_exe: python_script
          environments:
            - scope:
                type: any
              environment: python_env

  meta_task_schemas:
    - objective: system_analysis
      inputs:
        - parameter: x
      outputs:
        - parameter: g

loops:
  - name: markov_chain_state # [inner loop]
    tasks: [5, 6, 7]
    num_iterations: 9 # num_states - 1: (1 / p_0) - 1

  - name: proposal_update # [middle loop]
    tasks: [3, 4, 5, 6, 7]
    num_iterations: 5 # num_batches = num_samples * p_0 / num_chains_per_update

  - name: levels # [outer loop]
    tasks: [2, 3, 4, 5, 6, 7]
    num_iterations: 3
    termination_task: 2
    termination:
      path: outputs.is_finished
      condition: { value.equal_to: true }

resources:
  any:
    combine_scripts: true

meta_tasks:
  system_analysis:
    - schema: dummy_pre_processor # x -> y # python script
    - schema: model_sum_x # y -> sum_y via shell
    - schema: evaluate_limit_state_normal_sum # sum_y -> g # python script
      inputs:
        dimension: 200
        target_pf: 1e-4
      groups:
        - name: all

tasks:
  - schema: sample_direct_MC
    inputs:
      dimension: 200
    repeats: 100 # num_samples
  - schema: system_analysis
  - schema: collate_results # [outer loop]
    inputs:
      p_0: 0.1
  - schema: update_proposal # [middle loop]
  - schema: initialise_markov_chains # [middle loop]
    inputs:
      num_chains_per_update: 2
    sequences:
      - path: inputs.chain_index
        values::from_range:
          start: 0
          stop: 2 # num_chains_per_update
          step: 1
  - schema: generate_next_state # [inner loop]
    inputs:
      prop_std: 0.5 # initial std dev
  - schema: system_analysis # [inner loop]
  - schema: increment_chain # [inner loop]
    groups:
      - name: all
