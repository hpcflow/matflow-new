- objective: test_t1_bash
  inputs:
    - parameter: p1
  outputs:
    - parameter: p2
  actions:
    - environments:
        - scope:
            type: any
          environment: null_env
      abortable: true
      commands:
        - command: echo "$((<<parameter:p1>> + 100))"
          stdout: <<parameter:p2>>
        - command: |
            count=0
            while [ $count -le 100 ]
            do
                echo "count: $count; sleeping..."
                echo "This message goes to stderr" 1>&2
                ((count++))
                sleep 1
            done

- objective: test_t1_ps
  inputs:
    - parameter: p1
  outputs:
    - parameter: p2
  actions:
    - environments:
        - scope:
            type: any
          environment: python_env # null_env
      abortable: true
      commands:
        - command: |
            & {
              $count = 0
              while ($true) {
                Write-Host "count: $count; sleeping..."
                $count++
                if ($count -ge <<parameter:p1>>) {
                  break
                }
                Start-Sleep 1
              }
              Write-Output ((<<parameter:p1>> + 100))
            }
            <<executable:python_script>> --version
          stdout: <<parameter:p2>>

- objective: test_t2_bash
  inputs:
    - parameter: p2
  outputs:
    - parameter: p3
  actions:
    - environments:
        - scope:
            type: any
          environment: null_env
      abortable: true
      commands:
        - command: echo "$((<<parameter:p2>> + 100))"
          stdout: <<parameter:p3>>

- objective: test_t2_ps
  inputs:
    - parameter: p2
  outputs:
    - parameter: p3
  actions:
    - environments:
        - scope:
            type: any
          environment: null_env
      abortable: true
      commands:
        - command: Write-Output ((<<parameter:p2>> + 100))
          stdout: <<parameter:p3>>

# - objective: dummy_task_1
#   inputs:
#     - parameter: p1
#     - parameter: p2
#   outputs:
#     - parameter: p3
#   actions:
#     - environments:
#         - scope:
#             type: any
#           environment: python_env
#       input_file_generators:
#         - input_file: t1_infile_1
#           from_inputs: [p2]
#           script: <<script:write_t1_infile_1.py>>
#       commands:
#         - command: >-
#             Set-Content -Path .\test.txt -Value "hello from ${pwd}; p1=<<parameter:p1>> p2=<<parameter:p2>> <<file:t1_infile_1>>"
#       output_file_parsers:
#         p3:
#           from_files: [t1_outfile_1]
#           script: <<script:read_t1_outfile_1.py>>

# - objective: file_modifying_task
#   inputs:
#     - parameter: p1
#   outputs:
#     - parameter: p2
#   actions:
#     - environments:
#         - scope:
#             type: any
#           environment: python_env
#       input_file_generators:
#         - input_file: my_file
#           from_inputs: [p1]
#           script: <<script:write_my_file.py>>
#       commands:
#         - command: >-
#             Add-Content -Path <<file:my_file>> -Value "modified file contents!"
#       output_file_parsers:
#         p2:
#           from_files: [my_file]
#           script: <<script:read_my_file.py>>

- objective: generate_microstructure_seeds
  method: from_random
  inputs:
    - parameter: VE_size
    - parameter: num_grains
    - parameter: phase_label
  outputs:
    - parameter: microstructure_seeds
  actions:
    - script: <<script:damask/seeds_from_random.py>>
      script_data_in: direct
      script_data_out: direct
      script_exe: python_script
      environments:
        - scope:
            type: any
          environment: damask_parse_env

- objective: generate_volume_element
  method: from_voronoi
  inputs:
    - parameter: microstructure_seeds
    - parameter: VE_grid_size
    - parameter: homog_label
      default_value: SX
    - parameter: orientations
      default_value: null
  outputs:
    - parameter: volume_element
  actions:
    - script: <<script:damask/generate_volume_element_voronoi.py>>
      script_data_in: direct
      script_data_out: direct
      script_exe: python_script
      environments:
        - scope:
            type: any
          environment: damask_parse_env

- objective: sample_texture
  method: from_CTF_file
  implementation: mtex
  inputs:
    - parameter: compile
      default_value: false
      propagation_mode: explicit
    - parameter: CTF_file_path
    - parameter: specimen_symmetry
    - parameter: EBSD_phase
    - parameter: num_orientations
    - parameter: EBSD_reference_frame_transformation
      default_value: euler_to_spatial # or "spatial_to_euler" or null
    - parameter: EBSD_rotation # dict with keys "euler_angles_deg" list optional "keep_XY" bool, or "keep_euler" bool
      default_value: null
  outputs:
    - parameter: orientations
  actions:
    - script: <<script:mtex/sample_texture_CTF.m>>
      script_exe: compile_mtex
      environments:
        - scope:
            type: any
          environment: matlab_env
      rules:
        - rule:
            path: [inputs.compile]
            condition:
              value.equal_to: true

    - script: sample_texture_CTF
      script_data_in: json
      script_data_out: hdf5
      script_exe: run_compiled_mtex
      environments:
        - scope:
            type: any
          environment: matlab_env
      rules:
        - rule:
            path: [inputs.compile]
            condition:
              value.equal_to: true

    - script: <<script:mtex/sample_texture_CTF.m>>
      script_data_in: json
      script_data_out: hdf5
      script_exe: run_mtex
      environments:
        - scope:
            type: any
          environment: matlab_env
      rules:
        - rule:
            path: [inputs.compile]
            condition:
              value.equal_to: false

- objective: generate_orientations
  inputs:
    - parameter: num_orientations
  outputs:
    - parameter: orientations
  actions:
    - script: <<script:main_script_test.py>>
      script_data_in: json
      script_data_out: hdf5
      script_exe: python_script
      environments:
        - scope:
            type: any
          environment: python_env

- objective: define_p1
  inputs:
    - parameter: p1

- objective: define_load_case
  inputs:
    - parameter: load_case

# - objective: define_orientations
#   inputs:
#     - parameter: orientations
#       accept_multiple: true
#       labels:
#         oris_1: {}

- objective: simulate_VE_loading
  implementation: damask
  inputs:
    - parameter: volume_element
    - parameter: load_case
    - parameter: homogenization
    - parameter: damask_phases
    - parameter: damask_post_processing
    - parameter: VE_response_data
    - parameter: damask_viz
  outputs:
    - parameter: damask_log
    - parameter: damask_post_processing_result
    - parameter: VE_response
    - parameter: damask_viz_result
  actions:
    - environments:
        - scope:
            type: processing
          environment: damask_parse_env
        - scope:
            type: main
          environment: damask_env
      input_file_generators:
        - input_file: damask_geom_file
          from_inputs: [volume_element]
          script: <<script:damask/write_geom.py>>
        - input_file: damask_load_file
          from_inputs: [load_case]
          script: <<script:damask/write_load.py>>
        - input_file: damask_material_file
          from_inputs: [volume_element, homogenization, damask_phases]
          script: <<script:damask/write_material.py>>
      abortable: true
      commands:
        - command: <<executable:damask_grid>> --load load.yaml --geom geom.vti
          stdout: stdout.log
          stderr: stderr.log
      output_file_parsers:
        damask_log:
          from_files: [damask_stdout_file]
          script: <<script:damask/read_log.py>>
        damask_post_processing_result:
          from_files: [damask_hdf5_file]
          save_files: false
          script: <<script:damask/process_damask_HDF5.py>>
          inputs: [damask_post_processing]
        VE_response:
          from_files: [damask_hdf5_file]
          save_files: false
          script: <<script:damask/extract_damask_HDF5.py>>
          inputs: [VE_response_data]
        damask_viz_result:
          from_files: [damask_hdf5_file]
          save_files: [damask_viz_files]
          clean_up: [damask_viz_files]
          inputs: [damask_viz]
          outputs: [VE_response]
          script: <<script:damask/viz_damask_HDF5.py>>

- objective: dump_all_yield_stresses
  inputs:
    - parameter: VE_response
      group: all_simulations
    - parameter: yield_point
    - parameter: dump_path
  actions:
    - environments:
        - scope:
            type: any
          environment: damask_parse_env
      script: <<script:damask/dump_all_yield_stresses.py>>
      script_data_in: direct
      script_data_out: direct
      script_exe: python_script

- objective: fit_yield_function
  inputs:
    - parameter: yield_function_name
    - parameter: yield_point_criteria
    - parameter: VE_response
      multiple: true
      labels:
        uniaxial: {}
        multiaxial:
          group: multiaxial_load_cases
    - parameter: fit_yield_fixed_parameters
      default_value: null
    - parameter: fit_yield_initial_parameters
      default_value: null
    - parameter: fit_yield_opt_parameters
      default_value: null
  outputs:
    - parameter: fitted_yield_functions
  actions:
    - environments:
        - scope:
            type: any
          environment: formable_env
      script: <<script:formable/fit_yield_function.py>>
      script_data_in: direct
      script_data_out: direct
      script_exe: python_script
- objective: print_hello
  inputs:
    - parameter: my_name
      default_value: "world"
  actions:
    - rules:
        - path: resources.os_name
          condition: { value.equal_to: posix }
      commands:
        - command: echo "Hello, <<parameter:my_name>>!"
    - rules:
        - path: resources.os_name
          condition: { value.equal_to: nt }
      commands:
        - command: Write-Host "Hello, <<parameter:my_name>>!"

- objective: demo_adder
  inputs:
    - parameter: number_1
    - parameter: number_2
  outputs:
    - parameter: sum
  actions:
    - rules:
        - path: resources.os_name
          condition: { value.equal_to: posix }
      commands:
        - command: echo "$((<<parameter:number_1>> + <<parameter:number_2>>))"
          stdout: <<int(parameter:sum)>>
    - rules:
        - path: resources.os_name
          condition: { value.equal_to: nt }
      commands:
        - command: "Write-Output (<<parameter:number_1>> + <<parameter:number_2>>)"
          stdout: <<int(parameter:sum)>>

- objective: demo_sleep
  inputs:
    - parameter: max_sleep_time
      default_value: 1800 # 30 mins
  outputs:
    - parameter: sleep_time
  actions:
    - rules:
        - path: resources.shell
          condition: { value.in: [bash, wsl] }
      # abortable: true # fails on some powershell
      commands:
        - command: |
            count=0
            while [ $count -le <<parameter:max_sleep_time>> ]
            do
                echo "count: $count; sleeping..."
                ((count++))
                echo $count > sleep_seconds.txt
                sleep 1
            done
    - rules:
        - path: resources.shell
          condition: { value.equal_to: powershell }
      # abortable: true # fails on some powershell
      commands:
        - command: |
            $count = 0
            while ($true) {
                Write-Host "count: $count; sleeping..."
                $count++
                if ($count -ge <<parameter:max_sleep_time>>) {
                    break
                }
                $count | Out-File -FilePath sleep_seconds.txt
                Start-Sleep 1
            }
    - rules:
        - path: resources.shell
          condition: { value.in: [bash, wsl] }
      commands:
        - command: head -n 1 sleep_seconds.txt
          stdout: <<int(parameter:sleep_time)>>
    - rules:
        - path: resources.shell
          condition: { value.equal_to: powershell }
      commands:
        - command: Write-Output (Get-Content sleep_seconds.txt)
          stdout: <<int(parameter:sleep_time)>>
# - objective: hello_world
#   actions:
#     - commands:
#         - command: 'Write-Output "Hello, world!"'
#       environments:
#         - scope:
#             type: any
#           environment: null_env
# - objective: prepare_atoms_box
#   inputs:
#     - parameter: number_atoms
#   outputs:
#     - parameter: box
#     - parameter: atoms
#   actions:
#     - environments:
#         main: lammps_parse_env
#       commands:
#         - command: doSomething

# - objective: optimise_atoms
#   method: empirical_potential
#   inputs:
#     - parameter: box
#     - parameter: atoms
#     - parameter: empirical_potential
#   outputs:
#     - parameter: optimised_atoms
#   actions:
#     - environments:
#         main: lammps_env
#         processing: lammps_parse_env
#       input_files:
#         lammps_atoms_file:
#           from_inputs: [box, atoms]
#         lammps_input_script:
#           from_inputs: [empirical_potential]
#       outputs:
#         optimised_atoms:
#           from_files: [lammps_dump_files]
#       commands:
#         - command: <<executable:lammps>>
#           stdin: <<lammps_input_script>>

# - objective: generate_microstructure_seeds
#   inputs:
#     - parameter: num_seeds
#   outputs:
#     - parameter: microstructure_seeds
#   actions:
#     - environments:
#         - scope:
#             type: any
#           environment: damask_parse_env
#       commands:
#         - command: <<executable:python_script>> <<script>> ??

# - version: v2
#   objective: prepare_atoms_box
#   inputs:
#     - parameter: number_atoms
#   outputs:
#     - parameter: box
#     - parameter: atoms
#   actions:
#     - environments:
#         - scope:
#             type: main
#           environment:
#             name: lammps_parse_env
#             # lammps_version: 1.2 # a specifier
#         - scope:
#             type: input_file_generator
#           environment: lammps_parse_env
#         - scope:
#             type: output_file_parser
#           environment: lammps_parse_env
#       commands:
#         - command: doSomething <<parameter:number_atoms>>
#       output_file_parsers:
#         box:
#           from_files: [t1_outfile_1]
#         atoms:
#           from_files: [t1_outfile_1]

# - version: v1
#   objective: prepare_atoms_box
#   inputs:
#     - parameter: number_atoms
#   outputs:
#     - parameter: box
#     - parameter: atoms
#   actions:
#     - environments:
#         - scope:
#             type: main
#           environment: lammps_parse_env
#         - scope:
#             type: input_file_generator
#           environment: lammps_parse_env
#         - scope:
#             type: output_file_parser
#           environment: lammps_parse_env
#       commands:
#         - command: doSomething <<parameter:number_atoms>>
#       output_file_parsers:
#         box:
#           from_files: [t1_outfile_1]
#         atoms:
#           from_files: [t1_outfile_1]

# - objective: optimise_atoms
#   method: empirical_potential
#   inputs:
#     - parameter: box
#     - parameter: atoms
#     - parameter: empirical_potential
#   outputs:
#     - parameter: optimised_atoms
#   actions:
#     - environments:
#         - scope:
#             type: main
#           environment:
#             name: lammps_env
#             # lammps_version: 1.2
#         - scope:
#             type: processing
#           environment: lammps_parse_env
#       input_file_generators:
#         lammps_atoms_file:
#           from_inputs: [box, atoms]
#         lammps_input_script:
#           from_inputs: [empirical_potential]
#       output_file_parsers:
#         optimised_atoms:
#           from_files: [lammps_dump_files]
#       commands:
#         - command: <<executable:lammps>>
#           stdin: <<lammps_input_script>>
# - objective: simulate_RVE_loading
#   method: CP_FFT
#   inputs:
#     - parameter: material
#     - parameter: load_case
#     - paramater: RVE
#   outputs:
#     - parameter: RVE_response
#   actions:
#     - environments:
#         - scope:
#             type: any
#           environment:
#             name: damask_env
#       input_file_generators:
#         damask_load_file:
#           from_inputs: [load_case]
#         damask_material_file:
#           from_inputs: [material]
#         damask_geom_file:
#           from_inputs: [material, RVE]
#       output_file_parsers:
#         RVE_response:
#           from_files: [damask_hdf5_file, damask_stdout]
#       commands:
#         - command: DAMASK_grid --load <<input_file:damask_load_file>> --geom <<input_file:damask_geom_file>>
